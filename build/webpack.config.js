const fs = require('fs')
const path = require('path')
const StringReplacePlugin = require("string-replace-webpack-plugin");


function resolveThreeModule() {
  const fileLoaderStr='class FileLoader extends Loader {\n' + '\tconstructor(manager) {\n' + '\t\tsuper(manager);\n' + '\t}\n' + '\n' + '\tload(url, onLoad, onProgress, onError) {\n' + '\t\tif (url === undefined) url = \'\';\n' + '\t\tif (this.path !== undefined) url = this.path + url;\n' + '\t\turl = this.manager.resolveURL(url);\n' + '\t\tconst cached = Cache.get(url);\n' + '\n' + '\t\tif (cached !== undefined) {\n' + '\t\t\tthis.manager.itemStart(url);\n' + '\t\t\tsetTimeout(() => {\n' + '\t\t\t\tif (onLoad) onLoad(cached);\n' + '\t\t\t\tthis.manager.itemEnd(url);\n' + '\t\t\t}, 0);\n' + '\t\t\treturn cached;\n' + '\t\t} // Check if request is duplicate\n' + '\n' + '\n' + '\t\tif (loading[url] !== undefined) {\n' + '\t\t\tloading[url].push({\n' + '\t\t\t\tonLoad: onLoad,\n' + '\t\t\t\tonProgress: onProgress,\n' + '\t\t\t\tonError: onError\n' + '\t\t\t});\n' + '\t\t\treturn;\n' + '\t\t} // Initialise array for duplicate requests\n' + '\n' + '\n' + '\t\tloading[url] = [];\n' + '\t\tloading[url].push({\n' + '\t\t\tonLoad: onLoad,\n' + '\t\t\tonProgress: onProgress,\n' + '\t\t\tonError: onError\n' + '\t\t}); // create request\n' + '\n' + '\t\tconst req = new Request(url, {\n' + '\t\t\theaders: new Headers(this.requestHeader),\n' + '\t\t\tcredentials: this.withCredentials ? \'include\' : \'same-origin\' // An abort controller could be added within a future PR\n' + '\n' + '\t\t}); // record states ( avoid data race )\n' + '\n' + '\t\tconst mimeType = this.mimeType;\n' + '\t\tconst responseType = this.responseType; // start the fetch\n' + '\n' + '\t\tfetch(req).then(response => {\n' + '\t\t\tif (response.status === 200 || response.status === 0) {\n' + '\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\n' + '\t\t\t\t// e.g. \'file://\' or \'data://\'. Handle as success.\n' + '\t\t\t\tif (response.status === 0) {\n' + '\t\t\t\t\tconsole.warn(\'THREE.FileLoader: HTTP Status 0 received.\');\n' + '\t\t\t\t} // Workaround: Checking if response.body === undefined for Alipay browser #23548\n' + '\n' + '\n' + '\t\t\t\tif (typeof ReadableStream === \'undefined\' || response.body === undefined || response.body.getReader === undefined) {\n' + '\t\t\t\t\treturn response;\n' + '\t\t\t\t}\n' + '\n' + '\t\t\t\tconst callbacks = loading[url];\n' + '\t\t\t\tconst reader = response.body.getReader();\n' + '\t\t\t\tconst contentLength = response.headers.get(\'Content-Length\');\n' + '\t\t\t\tconst total = contentLength ? parseInt(contentLength) : 0;\n' + '\t\t\t\tconst lengthComputable = total !== 0;\n' + '\t\t\t\tlet loaded = 0; // periodically read data into the new stream tracking while download progress\n' + '\n' + '\t\t\t\tconst stream = new ReadableStream({\n' + '\t\t\t\t\tstart(controller) {\n' + '\t\t\t\t\t\treadData();\n' + '\n' + '\t\t\t\t\t\tfunction readData() {\n' + '\t\t\t\t\t\t\treader.read().then(({\n' + '\t\t\t\t\t\t\t\tdone,\n' + '\t\t\t\t\t\t\t\tvalue\n' + '\t\t\t\t\t\t\t}) => {\n' + '\t\t\t\t\t\t\t\tif (done) {\n' + '\t\t\t\t\t\t\t\t\tcontroller.close();\n' + '\t\t\t\t\t\t\t\t} else {\n' + '\t\t\t\t\t\t\t\t\tloaded += value.byteLength;\n' + '\t\t\t\t\t\t\t\t\tconst event = new ProgressEvent(\'progress\', {\n' + '\t\t\t\t\t\t\t\t\t\tlengthComputable,\n' + '\t\t\t\t\t\t\t\t\t\tloaded,\n' + '\t\t\t\t\t\t\t\t\t\ttotal\n' + '\t\t\t\t\t\t\t\t\t});\n' + '\n' + '\t\t\t\t\t\t\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n' + '\t\t\t\t\t\t\t\t\t\tconst callback = callbacks[i];\n' + '\t\t\t\t\t\t\t\t\t\tif (callback.onProgress) callback.onProgress(event);\n' + '\t\t\t\t\t\t\t\t\t}\n' + '\n' + '\t\t\t\t\t\t\t\t\tcontroller.enqueue(value);\n' + '\t\t\t\t\t\t\t\t\treadData();\n' + '\t\t\t\t\t\t\t\t}\n' + '\t\t\t\t\t\t\t});\n' + '\t\t\t\t\t\t}\n' + '\t\t\t\t\t}\n' + '\n' + '\t\t\t\t});\n' + '\t\t\t\treturn new Response(stream);\n' + '\t\t\t} else {\n' + '\t\t\t\tthrow new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);\n' + '\t\t\t}\n' + '\t\t}).then(response => {\n' + '\t\t\tswitch (responseType) {\n' + '\t\t\t\tcase \'arraybuffer\':\n' + '\t\t\t\t\treturn response.arrayBuffer();\n' + '\n' + '\t\t\t\tcase \'blob\':\n' + '\t\t\t\t\treturn response.blob();\n' + '\n' + '\t\t\t\tcase \'document\':\n' + '\t\t\t\t\treturn response.text().then(text => {\n' + '\t\t\t\t\t\tconst parser = new DOMParser();\n' + '\t\t\t\t\t\treturn parser.parseFromString(text, mimeType);\n' + '\t\t\t\t\t});\n' + '\n' + '\t\t\t\tcase \'json\':\n' + '\t\t\t\t\treturn response.json();\n' + '\n' + '\t\t\t\tdefault:\n' + '\t\t\t\t\tif (mimeType === undefined) {\n' + '\t\t\t\t\t\treturn response.text();\n' + '\t\t\t\t\t} else {\n' + '\t\t\t\t\t\t// sniff encoding\n' + '\t\t\t\t\t\tconst re = /charset="?([^;"\\s]*)"?/i;\n' + '\t\t\t\t\t\tconst exec = re.exec(mimeType);\n' + '\t\t\t\t\t\tconst label = exec && exec[1] ? exec[1].toLowerCase() : undefined;\n' + '\t\t\t\t\t\tconst decoder = new TextDecoder(label);\n' + '\t\t\t\t\t\treturn response.arrayBuffer().then(ab => decoder.decode(ab));\n' + '\t\t\t\t\t}\n' + '\n' + '\t\t\t}\n' + '\t\t}).then(data => {\n' + '\t\t\t// Add to cache only on HTTP success, so that we do not cache\n' + '\t\t\t// error response bodies as proper responses to requests.\n' + '\t\t\tCache.add(url, data);\n' + '\t\t\tconst callbacks = loading[url];\n' + '\t\t\tdelete loading[url];\n' + '\n' + '\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n' + '\t\t\t\tconst callback = callbacks[i];\n' + '\t\t\t\tif (callback.onLoad) callback.onLoad(data);\n' + '\t\t\t}\n' + '\t\t}).catch(err => {\n' + '\t\t\t// Abort errors and other errors are handled the same\n' + '\t\t\tconst callbacks = loading[url];\n' + '\n' + '\t\t\tif (callbacks === undefined) {\n' + '\t\t\t\t// When onLoad was called and url was deleted in `loading`\n' + '\t\t\t\tthis.manager.itemError(url);\n' + '\t\t\t\tthrow err;\n' + '\t\t\t}\n' + '\n' + '\t\t\tdelete loading[url];\n' + '\n' + '\t\t\tfor (let i = 0, il = callbacks.length; i < il; i++) {\n' + '\t\t\t\tconst callback = callbacks[i];\n' + '\t\t\t\tif (callback.onError) callback.onError(err);\n' + '\t\t\t}\n' + '\n' + '\t\t\tthis.manager.itemError(url);\n' + '\t\t}).finally(() => {\n' + '\t\t\tthis.manager.itemEnd(url);\n' + '\t\t});\n' + '\t\tthis.manager.itemStart(url);\n' + '\t}\n' + '\n' + '\tsetResponseType(value) {\n' + '\t\tthis.responseType = value;\n' + '\t\treturn this;\n' + '\t}\n' + '\n' + '\tsetMimeType(value) {\n' + '\t\tthis.mimeType = value;\n' + '\t\treturn this;\n' + '\t}\n' + '\n' + '}'
  const fileLoaderV108='class FileLoader extends Loader {\n' + '  constructor(manager) {\n' + '    super(manager);\n' + '  }\n' + '\n' + '  load(url, onLoad, onProgress, onError) {\n' + '    if ( url === undefined ) url = \'\';\n' + '\n' + '    if ( this.path !== undefined ) url = this.path + url;\n' + '\n' + '    url = this.manager.resolveURL( url );\n' + '\n' + '    var scope = this;\n' + '\n' + '    var cached = Cache.get( url );\n' + '\n' + '    if ( cached !== undefined ) {\n' + '\n' + '      scope.manager.itemStart( url );\n' + '\n' + '      setTimeout( function () {\n' + '\n' + '        if ( onLoad ) onLoad( cached );\n' + '\n' + '        scope.manager.itemEnd( url );\n' + '\n' + '      }, 0 );\n' + '\n' + '      return cached;\n' + '\n' + '    }\n' + '\n' + '    // Check if request is duplicate\n' + '\n' + '    if ( loading[ url ] !== undefined ) {\n' + '\n' + '      loading[ url ].push( {\n' + '\n' + '                             onLoad: onLoad,\n' + '                             onProgress: onProgress,\n' + '                             onError: onError\n' + '\n' + '                           } );\n' + '\n' + '      return;\n' + '\n' + '    }\n' + '\n' + '    // Check for data: URI\n' + '    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n' + '    var dataUriRegexResult = url.match( dataUriRegex );\n' + '\n' + '    // Safari can not handle Data URIs through XMLHttpRequest so process manually\n' + '    if ( dataUriRegexResult ) {\n' + '\n' + '      var mimeType = dataUriRegexResult[ 1 ];\n' + '      var isBase64 = !! dataUriRegexResult[ 2 ];\n' + '      var data = dataUriRegexResult[ 3 ];\n' + '\n' + '      data = decodeURIComponent( data );\n' + '\n' + '      if ( isBase64 ) data = atob( data );\n' + '\n' + '      try {\n' + '\n' + '        var response;\n' + '        var responseType = ( this.responseType || \'\' ).toLowerCase();\n' + '\n' + '        switch ( responseType ) {\n' + '\n' + '          case \'arraybuffer\':\n' + '          case \'blob\':\n' + '\n' + '            var view = new Uint8Array( data.length );\n' + '\n' + '            for ( var i = 0; i < data.length; i ++ ) {\n' + '\n' + '              view[ i ] = data.charCodeAt( i );\n' + '\n' + '            }\n' + '\n' + '            if ( responseType === \'blob\' ) {\n' + '\n' + '              response = new Blob( [ view.buffer ], { type: mimeType } );\n' + '\n' + '            } else {\n' + '\n' + '              response = view.buffer;\n' + '\n' + '            }\n' + '\n' + '            break;\n' + '\n' + '          case \'document\':\n' + '\n' + '            var parser = new DOMParser();\n' + '            response = parser.parseFromString( data, mimeType );\n' + '\n' + '            break;\n' + '\n' + '          case \'json\':\n' + '\n' + '            response = JSON.parse( data );\n' + '\n' + '            break;\n' + '\n' + '          default: // \'text\' or other\n' + '\n' + '            response = data;\n' + '\n' + '            break;\n' + '\n' + '        }\n' + '\n' + '        // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n' + '        setTimeout( function () {\n' + '\n' + '          if ( onLoad ) onLoad( response );\n' + '\n' + '          scope.manager.itemEnd( url );\n' + '\n' + '        }, 0 );\n' + '\n' + '      } catch ( error ) {\n' + '\n' + '        // Wait for next browser tick like standard XMLHttpRequest event dispatching does\n' + '        setTimeout( function () {\n' + '\n' + '          if ( onError ) onError( error );\n' + '\n' + '          scope.manager.itemError( url );\n' + '          scope.manager.itemEnd( url );\n' + '\n' + '        }, 0 );\n' + '\n' + '      }\n' + '\n' + '    } else {\n' + '\n' + '      // Initialise array for duplicate requests\n' + '\n' + '      loading[ url ] = [];\n' + '\n' + '      loading[ url ].push( {\n' + '\n' + '                             onLoad: onLoad,\n' + '                             onProgress: onProgress,\n' + '                             onError: onError\n' + '\n' + '                           } );\n' + '\n' + '      var request = new XMLHttpRequest();\n' + '\n' + '      request.open( \'GET\', url, true );\n' + '\n' + '      request.addEventListener( \'load\', function ( event ) {\n' + '\n' + '        var response = this.response;\n' + '\n' + '        Cache.add( url, response );\n' + '\n' + '        var callbacks = loading[ url ];\n' + '\n' + '        delete loading[ url ];\n' + '\n' + '        if ( this.status === 200 || this.status === 0 ) {\n' + '\n' + '          // Some browsers return HTTP Status 0 when using non-http protocol\n' + '          // e.g. \'file://\' or \'data://\'. Handle as success.\n' + '\n' + '          if ( this.status === 0 ) console.warn( \'THREE.FileLoader: HTTP Status 0 received.\' );\n' + '\n' + '          for ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n' + '\n' + '            var callback = callbacks[ i ];\n' + '            if ( callback.onLoad ) callback.onLoad( response );\n' + '\n' + '          }\n' + '\n' + '          scope.manager.itemEnd( url );\n' + '\n' + '        } else {\n' + '\n' + '          for ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n' + '\n' + '            var callback = callbacks[ i ];\n' + '            if ( callback.onError ) callback.onError( event );\n' + '\n' + '          }\n' + '\n' + '          scope.manager.itemError( url );\n' + '          scope.manager.itemEnd( url );\n' + '\n' + '        }\n' + '\n' + '      }, false );\n' + '\n' + '      request.addEventListener( \'progress\', function ( event ) {\n' + '\n' + '        var callbacks = loading[ url ];\n' + '\n' + '        for ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n' + '\n' + '          var callback = callbacks[ i ];\n' + '          if ( callback.onProgress ) callback.onProgress( event );\n' + '\n' + '        }\n' + '\n' + '      }, false );\n' + '\n' + '      request.addEventListener( \'error\', function ( event ) {\n' + '\n' + '        var callbacks = loading[ url ];\n' + '\n' + '        delete loading[ url ];\n' + '\n' + '        for ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n' + '\n' + '          var callback = callbacks[ i ];\n' + '          if ( callback.onError ) callback.onError( event );\n' + '\n' + '        }\n' + '\n' + '        scope.manager.itemError( url );\n' + '        scope.manager.itemEnd( url );\n' + '\n' + '      }, false );\n' + '\n' + '      request.addEventListener( \'abort\', function ( event ) {\n' + '\n' + '        var callbacks = loading[ url ];\n' + '\n' + '        delete loading[ url ];\n' + '\n' + '        for ( var i = 0, il = callbacks.length; i < il; i ++ ) {\n' + '\n' + '          var callback = callbacks[ i ];\n' + '          if ( callback.onError ) callback.onError( event );\n' + '\n' + '        }\n' + '\n' + '        scope.manager.itemError( url );\n' + '        scope.manager.itemEnd( url );\n' + '\n' + '      }, false );\n' + '\n' + '      if ( this.responseType !== undefined ) request.responseType = this.responseType;\n' + '      if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\n' + '\n' + '      if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : \'text/plain\' );\n' + '\n' + '      for ( var header in this.requestHeader ) {\n' + '\n' + '        request.setRequestHeader( header, this.requestHeader[ header ] );\n' + '\n' + '      }\n' + '\n' + '      request.send( null );\n' + '\n' + '    }\n' + '\n' + '    scope.manager.itemStart( url );\n' + '\n' + '    return request;\n' + '  }\n' + '\n' + '  setResponseType(value) {\n' + '    this.responseType = value;\n' + '    return this;\n' + '  }\n' + '\n' + '  setMimeType(value) {\n' + '    this.mimeType = value;\n' + '    return this;\n' + '  }\n' + '\n' + '}';
  const threePath = require.resolve('three')
  const replaceArr=[
    ['webgl2','webgl'],
    ['/OculusBrowser/g.test(navigator.userAgent)','false'],
    [fileLoaderStr,fileLoaderV108]
  ]
  let code = fs.readFileSync(path.resolve(threePath), 'utf8')
  replaceArr.forEach(value => {
    code=code.replace(value[0],value[1]);
  })
  console.log('code.indexOf(\'use this code quanchen cjs\')',code.indexOf(fileLoaderStr));
  return code
}

module.exports = {
  entry: path.join(__dirname, '../src/index'),
  target: 'web',
  output: {
    // path: path.join(__dirname, '../dist'),
    path: path.join(__dirname, '../example/miniprogram_npm/threejs-miniprogram'),
    filename: 'index.js',
    libraryTarget: 'commonjs',
  },
  module: {
    rules: [
      {
        test: /\.js$/,
        exclude: /node_modules/,
        loader: 'babel-loader',
        options: {
          presets: [
            "@babel/preset-env",
          ],
          plugins: ["@babel/plugin-proposal-class-properties"]
        }
      },
      {
        test: /\index.js$/,
        loader: StringReplacePlugin.replace({
          replacements: [
            {
              pattern: /__INJECT_THREE__/ig,
              replacement: () => {
                return resolveThreeModule()
              }
            }
          ]
        })
      }
    ]
  },
  plugins: [
      // an instance of the plugin must be present
      new StringReplacePlugin()
  ],
  optimization:{
    minimize: true,
  }
}
